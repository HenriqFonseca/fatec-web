/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { IndexConfiguration } from '../../../src/api/index_configuration';
import { Query } from '../../../src/core/query';
import { TargetId } from '../../../src/core/types';
import { FieldIndex } from '../../../src/model/field_index';
import { JsonObject } from '../../../src/model/object_value';
import * as api from '../../../src/protos/firestore_proto_api';
import { TestSnapshotVersion } from '../../util/helpers';
import { ActiveTargetMap } from './spec_builder';
interface DocumentOptions {
    hasLocalMutations?: boolean;
    hasCommittedMutations?: boolean;
}
export declare function parseQuery(querySpec: string | SpecQuery): Query;
/**
 * Runs a spec test case.
 *
 * The spec consists of an array of individual steps to run in sequence.
 */
export declare function runSpec(name: string, tags: string[], usePersistence: boolean, config: SpecConfig, steps: SpecStep[]): Promise<void>;
/** Specifies initial configuration information for the test. */
export interface SpecConfig {
    /** A boolean to enable / disable eager GC for memory persistence. */
    useEagerGCForMemory: boolean;
    /** The number of active clients for this test run. */
    numClients: number;
    /**
     * The maximum number of concurrently-active listens for limbo resolutions.
     * This value must be strictly greater than zero, or undefined to use the
     * default value.
     */
    maxConcurrentLimboResolutions?: number;
}
/**
 * The cumulative list of actions run against Persistence. This is used by the
 * Spec tests to fail specific types of actions.
 */
export declare type PersistenceAction = 'Get next mutation batch' | 'read document' | 'Allocate target' | 'Release target' | 'Execute query' | 'Handle user change' | 'Locally write mutations' | 'Acknowledge batch' | 'Reject batch' | 'Get highest unacknowledged batch id' | 'Get last stream token' | 'Set last stream token' | 'Get last remote snapshot version' | 'Set last remote snapshot version' | 'Apply remote event' | 'notifyLocalViewChanges' | 'Remote document keys' | 'Collect garbage' | 'maybeGarbageCollectMultiClientState' | 'Lookup mutation documents' | 'Get target data' | 'Get new document changes' | 'Synchronize last document change read time' | 'updateClientMetadataAndTryBecomePrimary' | 'getHighestListenSequenceNumber';
/**
 * Union type for each step. The step consists of exactly one `field`
 * set and optionally expected events in the `expect` field.
 */
export interface SpecStep {
    /** The index of the local client for multi-client spec tests. */
    clientIndex?: number;
    /** Listen to a new query (must be unique) */
    userListen?: SpecUserListen;
    /** Unlisten from a query (must be listened to) */
    userUnlisten?: SpecUserUnlisten;
    /** Perform a user initiated set */
    userSet?: SpecUserSet;
    /** Perform a user initiated patch */
    userPatch?: SpecUserPatch;
    /** Perform a user initiated delete */
    userDelete?: SpecUserDelete;
    /** Listens to a SnapshotsInSync event. */
    addSnapshotsInSyncListener?: true;
    /** Unlistens from a SnapshotsInSync event. */
    removeSnapshotsInSyncListener?: true;
    /** Loads a bundle from a string. */
    loadBundle?: string;
    /** Ack for a query in the watch stream */
    watchAck?: SpecWatchAck;
    /** Marks the query results as current */
    watchCurrent?: SpecWatchCurrent;
    /** Reset the results of a query */
    watchReset?: SpecWatchReset;
    /** Ack for remove or rejection of a query in the watch stream */
    watchRemove?: SpecWatchRemove;
    /** Document update in the watch stream */
    watchEntity?: SpecWatchEntity;
    /** Existence filter in the watch stream */
    watchFilter?: SpecWatchFilter;
    /** Snapshot ("NO_CHANGE") event in the watch stream. */
    watchSnapshot?: SpecWatchSnapshot;
    /** A step that the watch stream restarts. */
    watchStreamClose?: SpecWatchStreamClose;
    /** Ack the last write */
    writeAck?: SpecWriteAck;
    /** Fail a write */
    failWrite?: SpecWriteFailure;
    /** Add a new `waitForPendingWrites` listener. */
    waitForPendingWrites?: true;
    /** Fails the listed database actions. */
    failDatabase?: false | PersistenceAction[];
    /**
     * Set Index Configuration
     */
    setIndexConfiguration?: string | IndexConfiguration;
    /**
     * Run a queued timer task (without waiting for the delay to expire). See
     * TimerId enum definition for possible values).
     */
    runTimer?: string;
    /**
     * Process all events currently enqueued in the AsyncQueue.
     */
    drainQueue?: true;
    /** Enable or disable RemoteStore's network connection. */
    enableNetwork?: boolean;
    /** Clears the persistent storage in IndexedDB. */
    clearPersistence?: true;
    /** Changes the metadata state of a client instance. */
    applyClientState?: SpecClientState;
    /** Change to a new active user (specified by uid or null for anonymous). */
    changeUser?: string | null;
    /** Trigger a GC event with given cache threshold in bytes. */
    triggerLruGC?: number;
    /**
     * Restarts the SyncEngine from scratch, except re-uses persistence and auth
     * components. This allows you to queue writes, get documents into cache,
     * etc. and then simulate an app restart.
     */
    restart?: true;
    /** Shut down the client and close it network connection. */
    shutdown?: true;
    /**
     * Optional list of expected events.
     * If not provided, the test will fail if the step causes events to be raised.
     */
    expectedSnapshotEvents?: SnapshotEvent[];
    /**
     * Optional dictionary of expected states.
     */
    expectedState?: StateExpectation;
    /**
     * Optional expected number of onSnapshotsInSync callbacks to be called.
     * If not provided, the test will fail if the step causes events to be raised.
     */
    expectedSnapshotsInSyncEvents?: number;
    /**
     * Optional expected number of waitForPendingWrite callbacks to be called.
     * If not provided, the test will fail if the step causes events to be raised.
     */
    expectedWaitForPendingWritesEvents?: number;
}
export interface SpecUserListen {
    targetId: TargetId;
    query: string | SpecQuery;
}
/** [<target-id>, <query-path>] */
export declare type SpecUserUnlisten = [TargetId, string | SpecQuery];
/** [<key>, <value>] */
export declare type SpecUserSet = [string, JsonObject<unknown>];
/** [<key>, <patches>] */
export declare type SpecUserPatch = [string, JsonObject<unknown>];
/** key */
export declare type SpecUserDelete = string;
/** [<target-id>, ...] */
export declare type SpecWatchAck = TargetId[];
/** [[<target-id>, ...], <resume-token>] */
export declare type SpecWatchCurrent = [TargetId[], string];
/** [<target-id>, ...] */
export declare type SpecWatchReset = TargetId[];
export interface SpecError {
    code: number;
    message: string;
}
export interface SpecWatchRemove {
    targetIds: TargetId[];
    cause?: SpecError;
}
export interface SpecWatchSnapshot {
    version: TestSnapshotVersion;
    targetIds: TargetId[];
    resumeToken?: string;
}
export interface SpecWatchStreamClose {
    error: SpecError;
    runBackoffTimer: boolean;
}
export interface SpecWriteAck {
    /** The version the backend uses to ack the write. */
    version: TestSnapshotVersion;
    /**
     * Whether we should keep the write in our internal queue. This should only
   A{rAğÉAAµt(lfƒ"DØ˜"×ÆÍ·aDD°‘w ÄîßAƒÁŒ"é£XÜDˆ’_ïò	9­Æö„9G„Ñ™ƒ°ÍÀ„DHö‘~âámt óçAœsD9ÄmA¢è.lA¹p"Dìğ>ˆˆPˆ*‚bAˆ˜¢7÷  D`DD8›šX-„kxA""p‚	ä ƒˆÃªëû 
¼‘~ˆ°á;|á=t‚z±ˆ]†ƒ"Óìƒˆä¢ƒXÔQr†u_Hx%=d¶ˆ "Å%ˆƒˆ"’…ˆ©»PÂ›HA8çƒ ô¿
qšQsˆ—o?ˆ¢ş^´9S„ËåGA"tÜDˆàÑ;x BÕµ!XĞDHº…ÄÏNpgzƒ""r‚	ş 1âxê ş¾ˆÅ7ü áN€"D<ë AÄ"|À@>ˆˆ8`>:ˆ]…‚uÛ ƒ"€Òˆ(2”A"Ò§Xd"ˆà¸=ˆˆ8x>:ˆ–NˆÂˆ"Šƒ"ADDòmAæ¬ñ"^ ?ˆDP÷ƒAÄDP¿aKD!„nÇA"xÙ"‚¡u4}ûBmÀ9çƒ("xn"AÄ„ñòA{òşğ}µŸŒ±=HO’ê A„9»şøğö)›Y>\ÌA¸åTE ÙA×D°3È—ï2y
gDàv*ŠñóákØ£<†)Øõ—Ì—{dÎ%Lş¨Ø±cü† ‹y§N 2¿Iü^H!šßln0ãSÌ‡èk1}Õ†S9b*«×ˆÌ/4ßTØ1±ÂŸdO÷»\Î1Qêq°9aŠ'‘Ö˜™u‘ ÇJº5ÈÜc†»S§¾ 2ã¡ˆ†J~7š«FJ=6”oAB„%Ûi~˜!ÄîÅT»® 2ã¡ˆ†J~7š¯I@>L”z\ÈÌaŠ'‘Ö˜Üz„Èc£$(¯…[ˆÏçÒ1Iá‘Ã®È›>æ” jwıb•Ïé¡ÚÇ<IC>ræL”›t¹JSˆ7_Ûz²’c%¡*¶ê‘H˜.FŠ„øbI„0ÆPŠ Æ˜‘Œ)!ªñuÓg>bÀHè/¦„cEbŒ©(aÉ‘¢ŠáW>óEB|1†"1ÆT”0dH‰SÇ>ìA°¡‹˜"Ï÷˜Ùec*6(ÉŠ‘¢’Õš$	]Å’ğa¡AŒ1%ŒR"T1öBà5Ï|Å€‘Ğ_L 	ÆŠÄSæ3Â„+ìùAé—ó
ÍÄL…	cÇDJ(5†Q²ğxnÌ„c“$ìFI‰&Ç<J$9&TBª1|ì˜Äkc†¶AùŠÒ ‹ËNÈxÌnc>à!sÅ<Ø\Ï.!HÍó1$tSHÂ„1†"1ÆT”0dH‰QÅk½æ£wag>¡XAŒ1%ŒR"T1öB€^ùäÌSHÂ„1†"1ÆT”0dH‰QÅmAèš"¾˜Î|A‚‹›dÅæ#/DÒÃ|8Nó]	ğÅ’ˆ~Œ’Âw1PFÔYˆBÜt1£ùÇ`Í¾L…fcÅ"1RBTÙÛù¢ĞÅL‘	_Æ ŠÄSÂ1P%’#+Dğºg>bÀHè/¦„cEbŒ©(aÉ‘¢Š³¯|æ.Š„øbI„0ÆPŠ Æ˜‘Œ)!ªW^ó>B1E$|ƒ(BcLE‰cÇDJ(5†[l±¯1ÀÌ‘„pc’‰İÄ('Ñä˜D‰(Ç†J[5&Ÿ!ñÜ˜	Ç&I|öçrbs‰•P{Ó>èîı……öJÿ¢	¢Ÿ_ÿVhc™üSãEj/B$İƒ>lıŸšpAÚÿè– ¿R»Eö†øå¶Ú,çï6cÛÄœZc~øW9P›9]—Z¿vÄ{ò	ú¼?!-Ú|µ+-Ç¡).p^†¶Ô8Æ¿%¹-Üî•¸ê›™>•!CÁ£-Áåo¯ˆ¦‡®Xg"œW’¡õÙÜ­_|şŠ{oå±k.Äb5åv(ÇÌEw¸³q™–\áºtÖÖr3Wyê²µŒİ[’ĞQÄdË
ù-ËuıÕ¸âââW‘œ¸%C¶Kq®¹Ù…ZzhèãD3×X‹å—ÿÁß£­RgÕëpºÕËÏäÆ¡-«oƒC!£ÖCâ•éßg¡Mql;k–Ú”SÜ,øò+l±;‚ÏK²q‹Û#¢–”ß}k¢_ğÒ™ĞyÚà
Y}óŸ‡§g³
ÿ·®]^±MºtDÙüñím{. œ?E<Ìå+í¿õ®-ˆŞï`Zd:¿µã[óß8Y˜u‘bÖÓCzğÿyı`NËcsÆAŸp3öÊı‚ÿ¢;Ù×º/ÓìoàĞiKp³²sÕ¤²¾x7»^IL¹íîÍñ“"›éØ·”·¦½•/´8½«[_sûæ3-¿º“+5W±•«¬õò³å…Ó}\l=â¹«M¦õzHÿÿ{¾fÍZ‹ë\ïööéá¸®Ş5ùãÅY›Àü¬ıùßIà>ÿ§	yt³×N¤À;ƒtÒ©+çÙ9çÓÎb;¡uÙ©§N¤:©ìõÄĞ³‚'ôŞ­õ†ÑËŒ^wô^¯öÒÁ^GyŞ°ô”•·×y½§õŠ±¢ŞCöÔõ¦²GÓÉUÓ#zÛ
+*XVÂXİÜj«ÊXVÇYõà
%+\WTYËJUUV]¸zĞªW*Z+äZIÔj)WZRhÙAZëÖZChåF«:Z«×[Hi`+¢¬kØZJÊZê¬ÖÓZÅØ‚Që![KjZSÙ¢KËö^Àğ
·—^+÷^Åñ2½×B^ø_ÉuÃR^×òwUW*¾ô^ÇùŠÒš^õ\Ê¶˜bXÅ„»¹Ø+b˜ÅëÀKb,Æ(–˜¬ÂÄ:1ö X;ÆXbÈ“¨ØSÆÍ0³‚&ÌÙmÍ†1ËŒYvÌYoÎ2ÁYFeÙpÌ”U¶Öe³gÍŠq¢ÙCÎ™4Í¦rF&™š­Ô€¡n56ÔZ®ÔŠ£fzµ†Ô°Ö’J†5¦Ô´¥N«=µV¬5¨Õ²¤6Õ5ªÑ”l7Ü·à»	ávr·VÜ7ã»äÖ€7–Ü[ğ¼Qå6-7[µ¹uâíA·v¼·èİé&Q·¦¼ËÉ g9NÈ¹[Ë"—¹îÈ¹^Ì!$‚¹â¹aÉ)*n®ãsOÊcE¹‡Ì9)ÊMeN8;ÛØÂ.İvnØ»ÜØÇÎõvÙ;àÜ%TwNÙuË]W{v®¸wĞÚä.I;nÚwÔÒ)m™23ÈL!™·d‘i^æ‘Ì3©dæ’î…Ì´Mj›Ãl*ª¹vÍùl³¸Mh:ƒëĞy\ç‹Î7:í=M'§èöç¬¼¥…'Ğşé §ºüqÑæ‘›”6sÚMjç‡ªĞ.D"ºº÷E]f?WÎxúÔúH®s.É¸`˜£Jn[r¸Š“ëşÜ à  µ       
       ‡                                  dfffdfff                                            
                       °°  °   º       {  °  ©«   ° ‹	›«°   p‡» « 
`uºº

`°°	 ª `                        K¶¾¤$LLÆÎ¤$MBÖ‚	œh'@!Q1…UP…`qY±…]p¸ÑosÈ$QJ¦§l|J¥¼TBJeåTURZeåUVbjeåVWr	e[F¶%¥[\¾Æ%¥\]ÎÖ%LRÆdtÌÍÇdÊF&¦deNV&¦ef^f&¦fgnv&˜`²ffkkºÂæfllÊÒæfmæ$lNNçü|B§gttJRçguuZbçgvvjrç!r™ÌÂıƒ248Xƒ		›Ğ	ŸP(……RT8X……VXx˜……Z\¸Ø…BÈ††moè‡‡qs(H‡„u‘±rñ‰‰‘“(H‰‰•—hˆ‰‰™›¨È‰ˆ"Š¬®ØøŠ‹°²8‹‹´‰X‘›ŸÑ(ĞÒ8ÔÖXxØÚ˜¸ÜÂØ1íÈèïñ(óõH’Œ!²ò!‘r	)‘‘Ii‘‘‰©‘‘É$\lDF´Áón»À‰Î9_?¥ƒ‹„³=ãÛ“Ó=>ßãS>>çë“(9ƒ2:hèƒBå#TBB'+”ÔBE/]µõUVa5*_­ĞÒ:­­ÔÖZz­­ØÚšº­­ÜÂÚ®±íÊê®¯ïñ
*¯¯óõJ‰¬#stŸ „À"€	 `*à2Àà` :¡^pæ2Ì/%Y«½}ŞåPÌ$ÍİPPíÑ@euÑÑ…•ÑÑ¥JĞ¤LNÚú¤Ry(…•ÒÒ)*¥µÒÒ+,ÅÕÒÒ-.åÒ6mSS78}SS9:­S¨$Êê¨«H•TTIJ­TTKL½ÍTTMNİíTPAeÕÑ_•ÕYZ¥JÔ¬ÌÎÚş¬É“9&{óÿ@*åğ)Ùb€ ajÇxxç“{<ÈÉ‹›<<ÊË«»<<Ì
œ¬@@¼Ì@@Üì@ dÁÁt„ÁÌ­÷t;õˆ=ía]Ç ‰iƒ-+9†ñ“Çúê<yL›§Çyxz¬®×÷z{°²7{{´ˆWùùšÏ'ÿ}ĞÒ7}}ÔÖWw}}ØÚ—·}}ÜÁ×~ñíÇç~ïñ'óõG|°ğr(ìÇ[l;µpØ$™k'?Q­ Ğ°-ğ‚³Ãä[7.šn¹ı6ë2Ş3()I!â!°¸‹,ØB ¸6!ÅnY°A7}OãZÈœşpRÜLpï4ƒİæ°5òü;“§ÔÊ£öşch7„üd]¹Y4:	Ó¦¤_]ÿıªŒ5ıö{ÔârO?¬… 9íf~Aä•ëfİ‰‘Ëæ.¾OARGóÃßbûMY–bİ\ÿ]óNCl-ş7æƒLT’9eïBİÃÏ‰~–¥‘òå­[æÉ¬>f!)÷®/h